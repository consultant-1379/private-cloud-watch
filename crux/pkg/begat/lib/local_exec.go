package lib

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/erixzone/crux/pkg/begat/common"
	"github.com/erixzone/crux/pkg/begat/merkle"
	"github.com/erixzone/crux/pkg/crux"
)

/*
	this is a simple implementation of the IBexec interface.
hopefully, it is mostly straightforward. one aspect is not, and that has
to do with how file system events are handled.

	the routing of filesystem events (FSEs) is complicated by the fact
that they are generated by the execution servers, but consumed by the per-chore
management routines, which may be (if not now, soon) in other processes and
eventually on other systems. the solution herein is built via

	+ we handle the inherent asynchrony (in the interface) via Go's channels
	+ when the per-chore manager submits a recipe for execution, one of the parameters
is a channel of relevent FSEs
	+ when an execution server runs a recipe, it sends its FSEs to a centralised fsroute(r).
for simplicity, all execution servers merge into a single fsroute.
	+ when we schedule a job, we register its feedback FSE channel with fsroute so
that it can get its updates.
	+ that feedback FSE channel also gets primed with the files available within the standardised
environment plus any files mounted in.
	+ keep in mind that the job submitted has to already know about FSEs because in order
to preload any input files from pastiche, we need to know their hash.

	the precise linkage is that the FSE channel input to fsroute is an initialisation argument
to BIexec, so that any FSE generation knows where to send them. that means the fsroute is internal to begat
and thus, its control channel is available to the per-chore managers so that they can register for
FSEs to be routed back to them.

	note also that the recipe execution status messages are now a FSE, and so you'll see them interpolated in.

ALERT: TBD:
how do we handle mixing of job's namespaces? (with comingled eventFSs)
*/

type job struct {
	sync.Mutex
	c     *Chore
	files map[string]common.Hash
}

// TestFS implements the BIfs interface
type TestFS struct {
	FsrQuit chan bool
	FsrCmd  chan FSRouterCmd
	Fsr     chan EventFS
}

// LocalFS returns a BIfs implemntation
func LocalFS() *TestFS {
	var e TestFS
	// start up the fsrouter
	e.FsrCmd = make(chan FSRouterCmd)
	e.FsrQuit = make(chan bool)
	e.Fsr = make(chan EventFS, 99)
	go FSRouter(e.FsrCmd, e.Fsr, e.FsrQuit)

	return &e
}

// Pub registers an EventFS publisher with a label on the given channel
func (lfs *TestFS) Pub(label string, ch <-chan EventFS) {
	// no use for label yet
	go lfs.splice(ch)
}

// PubClose close that publisher
func (lfs *TestFS) PubClose(ch <-chan EventFS) {
	// we could do something complicated but this will do for now
}

// Sub manipulate a subscriber
func (lfs *TestFS) Sub(cmd FSRouterCmd) {
	lfs.FsrCmd <- cmd
}

// Quit bye bye
func (lfs *TestFS) Quit() {
	lfs.FsrQuit <- true
}

func (lfs *TestFS) splice(ch <-chan EventFS) {
	var zero EventFS
	for {
		e := <-ch
		if e == zero {
			break
		}
		lfs.Fsr <- e
	}
}

// TestExec helps implement a BIexec
type TestExec struct {
	sync.Mutex
	base     string
	n        int
	quitting int
	work     []*job
	efs      map[string][]EventFS
	fsi      BIfs
}

// LocalExec returns a BIexec implemntation
func LocalExec(fsi BIfs) *TestExec {
	var e TestExec
	e.work = make([]*job, 0, 2)
	b, err := ioutil.TempDir("/tmp", "begat")
	e.base = b
	e.efs = make(map[string][]EventFS)
	crux.Assert(err == nil)
	e.fsi = fsi

	return &e
}

// InitN starts up n exection points
func (e *TestExec) InitN(n int) {
	crux.Assert(n > 0)
	e.Lock()
	e.n = n
	e.Unlock()
	for i := 0; i < n; i++ {
		go e.server(i)
	}
}

// Quit causes a BIexec to exit
func (e *TestExec) Quit() {
	e.Lock()
	e.quitting = e.n
	e.Unlock()
	for {
		time.Sleep(100 * time.Millisecond)
		e.Lock()
		if e.quitting == 0 {
			e.Unlock()
			break
		}
		e.Unlock()
	}
	os.RemoveAll(e.base)
}

// RouterCtl send s a router command
func (e *TestExec) RouterCtl(ec FSRouterCmd) {
	e.fsi.Sub(ec)
}

// Exec executes a single chore
func (e *TestExec) Exec(ch *Chore) error {
	fmt.Printf("got job %+v\n", *ch)
	e.Lock()
	e.work = append(e.work, &job{c: ch})
	e.Unlock()
	return nil
}

func (e *TestExec) server(id int) {
	mydir := filepath.Join(e.base, fmt.Sprintf("node%d", id))
	for {
		fmt.Printf("looking for work %d\n", id)
		e.Lock()
		fmt.Printf("\tchecking for work %d\n", id)
		if e.quitting > 0 {
			e.quitting--
			e.Unlock()
			fmt.Printf("\tquitting %d\n", id)
			return
		}
		if len(e.work) == 0 {
			e.Unlock()
			time.Sleep(100 * time.Millisecond)
			fmt.Printf("\tsleeping %d\n", id)
			continue
		}
		fmt.Printf("\there!\n")
		j := e.work[0]
		e.work = e.work[1:]
		e.Unlock()
		runjob(j, mydir, e.fsi)
	}
}

func runjob(j *job, base string, fsi BIfs) {
	fmt.Printf("++++ base %s\n", base)
	j.files = make(map[string]common.Hash)
	// first clean away prior debris; start squeaky clean
	os.RemoveAll(base)
	os.Mkdir(base, 0777)
	fmt.Printf("about to run chore %+v\n", *j.c)
	ch := make(chan merkle.EventMerkle, 10)
	fs := make(chan EventFS, 99)
	fsi.Pub(j.c.RunID, fs)
	go j.merkleMon(base, fs, ch)
	performMounts(j.c.Mounts, base)
	// copy in any inputs
	copyin(base, j.c, j)
	// execute the recipe
	var cmd *exec.Cmd
	if j.c.D.Recipe.Interp == "" {
		cmd = exec.Command("/bin/sh", "-xv")
	} else {
		cmd = exec.Command(j.c.D.Recipe.Interp)
	}
	cmd.Stdin = strings.NewReader(string(j.c.D.Recipe.Recipe))
	// the environment needs to be setup properly; this doesn't do that but does allow testing
	cmd.Env = append(os.Environ(), j.c.environChore()...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Dir = filepath.Join(base, j.c.Dir)
	fmt.Printf("executing '%v' from '%s' with env '%v'\n", cmd.Args, j.c.D.Recipe.Recipe, cmd.Env)
	//	var out bytes.Buffer
	//	cmd.Stdout = &out
	var eret *crux.Err
	err := cmd.Run()
	if err != nil {
		eret = crux.ErrE(err)
	}
	// copy out any products
	copyout(base, j.c.Dir, j.c.D.Outputs)
	_, err = merkle.UpdateHashTree(base, ch, true, true, nil)
	if err != nil {
		eret = crux.ErrE(err)
	}
	fs <- EventFS{Op: FSEexecstatus, Path: j.c.RunID, Err: eret.String()}
	fsi.PubClose(fs)
}

func (j *job) merkleMon(base string, fch chan EventFS, mch chan merkle.EventMerkle) {
	for {
		m := <-mch
		fmt.Printf("-- merkle: %+v\n", m)
		rel, _ := filepath.Rel(base, m.File)
		if rel != "" {
			m.File = rel
			fmt.Printf("\treset merkle name to %s\n", m.File)
		}
		switch m.Op {
		case merkle.MerkleNew, merkle.MerkleChange:
			fch <- EventFS{Op: FSEnormal, Path: m.File, Hash: common.GetHashString(m.Hash)}
			j.Lock()
			j.files[m.File] = common.GetHashString(m.Hash)
			j.Unlock()
		case merkle.MerkleDelete:
			fch <- EventFS{Op: FSEdelete, Path: m.File, Hash: 0}
			j.Lock()
			delete(j.files, m.File)
			j.Unlock()
		case merkle.MerkleDone, merkle.MerkleExit:
			//close(fch)
			return
		}
	}
}

func performMounts(mnts []Mount, base string) {
	for _, m := range mnts {
		i := strings.IndexByte(m.What, ':')
		if i == -1 {
			crux.Assert(false) // should be a log.Error
		}
		switch m.What[:i] {
		case "lfs":
			from, err := filepath.Abs(m.What[i+1:])
			if err != nil {
				// log error
				from = m.What[i+1:]
			}
			cmd := exec.Command("cp", "-r", from, filepath.Join(base, m.Where))
			fmt.Printf("+++LFS: %v\n", cmd.Args)
			b, err := cmd.CombinedOutput()
			if err != nil {
				fmt.Printf("--run.cmd got error %s; stdio=\n%s\n", err.Error(), string(b))
				crux.Assert(false)
			}
		default:
			fmt.Printf("unknown mount '%s'\n", m.What[:i])
			crux.Assert(false)
		}
	}
}

// PrimeFS loads up a chore with the EventFS's inherent in the mounts
func (e *TestExec) PrimeFS(c *Chore) {
	fs := make(chan EventFS, 99)
	e.fsi.Pub("prime."+c.RunID, fs)
	defer e.fsi.PubClose(fs)
	key := canonMount(c.Dir, c.Mounts)
	e.Lock()
	if ee, ok := e.efs[key]; ok {
		e.Unlock()
		for _, e := range ee {
			fs <- e
		}
		return
	}
	b, err := ioutil.TempDir("/tmp", "begat")
	if err != nil {
		e.Unlock()
		panic(err)
	}
	performMounts(c.Mounts, b)
	ch := make(chan merkle.EventMerkle, 10)
	go func() {
		_, err := merkle.UpdateHashTree(b, ch, true, true, nil)
		if err != nil {
			crux.Assert(false)
		}
	}()
	var fss []EventFS
	for {
		em := <-ch
		if em.Op == merkle.MerkleDone {
			break
		}
		rel, _ := filepath.Rel(b, em.File)
		if rel != "" {
			f := EventFS{Op: FSEnormal, Path: rel, Hash: common.GetHashString(em.Hash)}
			fss = append(fss, f)
		}
	}
	e.efs[key] = fss
	e.Unlock()
	for _, f := range fss {
		fs <- f
	}
	close(fs)
	return
}

func canonMount(base string, mnts []Mount) string {
	const sep = "!?!"
	b, err := json.Marshal(mnts)
	crux.Assert(err == nil)
	return base + sep + string(b)
}

func (ch *Chore) environChore() []string {
	var ret []string
	/*	newinput
		nproc
		pid
		output
	*/
	ret = append(ret, fmt.Sprintf("alloutput=%s", strings.Join(ch.D.Outputs, " ")))
	ret = append(ret, fmt.Sprintf("input=%s", strings.Join(ch.D.Inputs, " ")))
	return ret
}

func copyin(base string, ch *Chore, j *job) {
	for _, i := range ch.InEnts {
		/* TBD */
		if (i.Status != EntExist) || !i.Depend {
			continue
		}
		cmd := exec.Command("pastiche", "wrest", i.Hash.String(), filepath.Join(base, i.Name))
		cmd.Stderr = os.Stderr
		cmd.Dir = filepath.Join(base, j.c.Dir)
		fmt.Printf("executing copyin '%v' \n", cmd.Args)
		if err := cmd.Run(); err != nil {
			panic(err)
		}
	}
}

func copyout(base string, dir string, outs []string) {
	var args []string
	args = append(args, "retain")
	args = append(args, outs...)
	cmd := exec.Command("pastiche", args...)
	cmd.Stderr = os.Stderr
	cmd.Dir = filepath.Join(base, dir)
	fmt.Printf("executing '%v'\n", cmd.Args)
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}
