package khan

import (
	"fmt"
	"math"
	"math/rand"
	"strings"

	"github.com/erixzone/crux/gen/khan"
	"github.com/erixzone/crux/pkg/crux"
	"github.com/erixzone/crux/pkg/horde"
	kd "github.com/erixzone/crux/pkg/khan/defn"
)

// lineup generates a distribution of services that satisifies the spec.
func lineup(adm horde.Administer, spec string, cur *diaspora) ([]Where, []*kd.After, *crux.Err) {
	rd := strings.NewReader(spec)
	// nex creates the function: func NewLexerWithInit(in io.Reader, initFun func(*Lexer)) *Lexer
	// go tool yacc creates the function: func yyParse(yylex yyLexer) int
	ret := khangen.Parse("spec", rd, false)
	if ret != nil {
		return nil, nil, crux.ErrE(ret)
	}
	parsedExprs := khangen.ParsedExprs
	afters := khangen.ParsedAfters
	/* change to logging
	if false {
		fmt.Printf("exprs = %d\n", len(parsedExprs))
		for i, e := range parsedExprs {
			fmt.Printf("%d: %s\n", i, e.String())
		}
	}
	*/
	// get everything we need from the KV store
	labels, nodes, err := extractKV(adm)
	//fmt.Printf("++++++labels=%+v nodes=%+v err=%+v\n", labels, nodes, err)
	if err != nil {
		return nil, nil, err
	}
	// substitute in the label stuff now
	all := make([]int, len(nodes))
	for i := range nodes {
		all[i] = i
	}
	subLabels(parsedExprs, labels, all)
	// simplify constant expressions
	evalConsts(parsedExprs, all)
	for _, a := range afters {
		for _, c := range a.Pre {
			evalConst(c.Vale, all)
			c.Val = c.Vale.V.Num
		}
	}
	// now whack at the expressions
	donech := make(chan bool)
	solns := make(chan *diaspora)
	/*
		a word to the wise:
		we want the "best" solution out of all the solutions generated by reduce. as you can see below,
		this means the solution "closest" to the current state (which means minimal changes).
		because this logic belongs here, we implement this by having a local goroutine do the "best"
		calculation, and have reduce() send all its solution to that goroutine over a channel.
	*/
	var best *diaspora
	var bestD int64 = math.MaxInt64 // best distance
	var bestS int64 = math.MaxInt64 // best spread
	var bestN int32                 // count of solutions we've seen for this spread
	go func(ch chan *diaspora) {
		for {
			d, ok := <-ch
			if !ok {
				donech <- true
				return
			}
			/*
				this is where we do spreading. the simple scheme of picking the best (least)
				distance favors early solutions. we'd like to improve on that in two ways:
					- favor spread out solutions across more nodes (proxy for load balancing)
					- pick randomly among viable solutions
			*/
			if dd := distance(cur, d); dd < bestD {
				bestD = dd
				bestS = math.MaxInt64 // reset best spread
				best = d
			}
			ss := spread(d)
			if ss < bestS {
				// fmt.Printf("new bestS: %d beats %d\n", ss, bestS)
				bestS = ss
				best = d
				bestN = 0 // reset random pick counter
			}
			if ss == bestS {
				bestN++
				if rand.Int31n(bestN) == 0 {
					// fmt.Printf("random pick wins! bestN=%d\n", bestN)
					best = d
				}
			}
		}
	}(solns)
	_, er := reduce(parsedExprs, &kd.Vset{V: make(map[string]*kd.Value, 0)}, all, newDiaspora(), solns)
	close(solns)
	if er != nil {
		return nil, nil, er
	}
	<-donech
	//fmt.Printf("best = %+v; cur=%+v; dist=%d spread=%d\n", best, cur, bestD, bestS)
	var wh []Where
	if best != nil {
		best.guard.Lock()
		for k, dist := range best.m {
			for i, c := range dist {
				if c > 0 {
					wh = append(wh, Where{service: k, node: nodes[i], count: c})
				}
			}
		}
		best.guard.Unlock()
	}
	//	fmt.Printf("lineup returns %+v\n", wh)
	return wh, afters, nil
}

func distance(a, b *diaspora) int64 {
	/*
		first, build a map indexed by node "|" service(as int) of the instance
		count in each distribtion (or diaspora).
		also generate a count of instances by node.
	*/
	type int2 struct{ a, b int }
	c := make(map[string]*int2, 0)
	ac := make(map[string]int, 0)
	bc := make(map[string]int, 0)
	if a != nil {
		a.guard.Lock()
		for s, m := range a.m {
			ac[s] = ac[s] + 1
			for i := range m {
				k := fmt.Sprintf("%s|%d", s, i)
				i2, ok := c[k]
				if !ok {
					i2 = &int2{}
					c[k] = i2
				}
				i2.a = m[i]
			}
		}
		a.guard.Unlock()
	}
	if b != nil {
		b.guard.Lock()
		for s, m := range b.m {
			bc[s] = bc[s] + 1
			for i := range m {
				k := fmt.Sprintf("%s|%d", s, i)
				i2, ok := c[k]
				if !ok {
					i2 = &int2{}
					c[k] = i2
				}
				i2.b = m[i]
			}
		}
		b.guard.Unlock()
	}
	// now compute the variance. using the sum of squares (rather than just differences)
	// penalises larger changes more heavily
	var d int64
	for _, i2 := range c {
		x := i2.a - i2.b
		d += int64(x * x)
	}
	return d
}

// lots of choices here; just do normal sum of squares
func spread(d *diaspora) int64 {
	var sp int64
	d.guard.Lock()
	for _, m := range d.m {
		count := 0
		for _, c := range m {
			count += c
		}
		sp += int64(count * count)
	}
	d.guard.Unlock()
	return sp
}

func extractKV(h horde.Administer) (*kd.Vset, []string, *crux.Err) {
	labels := &kd.Vset{V: make(map[string]*kd.Value, 0)}
	var nodes []string
	nmap := make(map[string]int, 0)
	ns, err := h.Nodes()
	if err != nil {
		return labels, nodes, err
	}
	for _, k := range ns {
		// map node name to an int
		name := k.Name
		im, ok := nmap[name]
		if !ok {
			im = len(nodes)
			nmap[name] = im
			nodes = append(nodes, name)
		}
		for _, s := range k.Tags {
			// add us to this label
			if _, ok = labels.V[s]; !ok {
				labels.V[s] = &kd.Value{IsNum: false, Set: make([]int, 0)}
			}
			labels.V[s].Set = append(labels.V[s].Set, im)
		}
	}
	return labels, nodes, nil
}

func subLabels(exprs []*kd.Expr, labels *kd.Vset, all []int) {
	for _, e := range exprs {
		e.Traverse(func(ex *kd.Expr) {
			switch ex.Op {
			case kd.OpAll:
				ex.V = kd.SetValue(all)
			case kd.OpLabel:
				labels.Guard.Lock()
				if v, ok := labels.V[ex.Str]; ok && !v.IsNum {
					ex.V = kd.SetValue(v.Set)
				}
				labels.Guard.Unlock()
			}
		})
	}
}

func (w Where) String() string {
	return fmt.Sprintf("%s[%d@%s]", w.service, w.count, w.node)
}
