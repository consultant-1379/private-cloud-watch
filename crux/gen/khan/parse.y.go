//line parse.y:5
package khangen

import __yyfmt__ "fmt"

//line parse.y:5

import (
	"fmt"
	kd "github.com/erixzone/crux/pkg/khan/defn"
	"io"
	"strconv"
)

var ParsedExprs []*kd.Expr
var ParsedAfters []*kd.After

//line parse.y:19
type ParseSymType struct {
	yys           int
	num           int
	str           string
	expr          *kd.Expr
	exprlist      []*kd.Expr
	after         *kd.After
	afterlist     []*kd.After
	condition     *kd.Condition
	conditionlist []*kd.Condition
	pair          []string
	truth         bool
	strlist       []string
}

const NUMBER = 57346
const STRING = 57347
const IDENTIFIER = 57348
const PLUS = 57349
const MINUS = 57350
const MULT = 57351
const DIVIDE = 57352
const COMMA = 57353
const AND = 57354
const NOT = 57355
const OR = 57356
const ASSIGNS = 57357
const LPAR = 57358
const RPAR = 57359
const PICK = 57360
const PICKH = 57361
const SIZE = 57362
const LABEL = 57363
const ALL = 57364
const START = 57365
const AFTER = 57366
const OF = 57367
const PERCENT = 57368
const DOT = 57369

var ParseToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"NUMBER",
	"STRING",
	"IDENTIFIER",
	"PLUS",
	"MINUS",
	"MULT",
	"DIVIDE",
	"COMMA",
	"AND",
	"NOT",
	"OR",
	"ASSIGNS",
	"LPAR",
	"RPAR",
	"PICK",
	"PICKH",
	"SIZE",
	"LABEL",
	"ALL",
	"START",
	"AFTER",
	"OF",
	"PERCENT",
	"DOT",
}
var ParseStatenames = [...]string{}

const ParseEofCode = 1
const ParseErrCode = 2
const ParseInitialStackSize = 16

//line parse.y:168

type FlexLex struct {
	lval *ParseSymType
}

func (fl *FlexLex) Lex(lv *ParseSymType) int {
	ret := yylex()
	*lv = lval
	return ret
}

func (fl *FlexLex) Error(e string) {
	fmt.Printf("error:%s:%d: %s\n", yyfile, yylineno, e)
}

func Parse(filename string, rdr io.Reader, noisy bool) error {
	if noisy {
		ParseDebug = 4
	} else {
		ParseDebug = 0
	}
	var fl FlexLex
	yyin = rdr
	yyfile = filename
	ret := ParseParse(&fl)
	if ret == 1 {
		return fmt.Errorf("parse failed")
	}
	return nil
}

//line yacctab:1
var ParseExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const ParsePrivate = 57344

const ParseLast = 96

var ParseAct = [...]int{

	45, 3, 44, 36, 11, 66, 35, 46, 20, 40,
	40, 18, 29, 34, 21, 22, 23, 50, 51, 52,
	53, 28, 4, 54, 38, 41, 41, 17, 16, 9,
	37, 15, 24, 14, 5, 6, 58, 8, 7, 12,
	39, 42, 12, 12, 13, 13, 56, 69, 68, 29,
	12, 59, 13, 52, 53, 67, 64, 65, 60, 61,
	62, 63, 4, 12, 33, 13, 32, 70, 47, 9,
	27, 26, 25, 48, 5, 6, 31, 8, 7, 50,
	51, 52, 53, 55, 50, 51, 52, 53, 49, 1,
	30, 43, 57, 10, 19, 2,
}
var ParsePact = [...]int{

	56, -1000, 56, 51, 18, 15, 12, -1000, 11, 56,
	-15, 51, 56, 56, 16, 66, 65, 64, 51, -1000,
	43, -1000, 27, 51, 71, 55, 53, -4, -18, -24,
	13, -1000, 5, 5, -1000, 6, 62, -1000, 68, 77,
	-1000, 7, 72, 6, -1000, -1000, 10, -1000, -1000, 56,
	5, 5, 5, 5, 56, 56, -1000, -20, -1000, 38,
	44, 44, -1000, -1000, 31, 30, 43, -1000, -1000, -1000,
	-1000,
}
var ParsePgo = [...]int{

	0, 95, 1, 7, 94, 93, 0, 92, 2, 91,
	90, 89,
}
var ParseR1 = [...]int{

	0, 11, 1, 1, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 10, 10, 5, 5, 4, 9,
	9, 8, 8, 6, 6, 7, 7, 3, 3, 3,
	3, 3, 3,
}
var ParseR2 = [...]int{

	0, 2, 1, 2, 3, 5, 8, 8, 1, 4,
	2, 3, 3, 1, 1, 3, 0, 2, 4, 1,
	2, 1, 4, 1, 3, 0, 1, 1, 4, 3,
	3, 3, 3,
}
var ParseChk = [...]int{

	-1000, -11, -1, -2, 6, 18, 19, 22, 21, 13,
	-5, -2, 12, 14, 15, 16, 16, 16, -2, -4,
	23, -2, -2, -2, 16, 6, 6, 6, -6, 6,
	-10, 5, 11, 11, 17, 24, 27, 17, 11, -3,
	4, 20, -3, -9, -8, -6, -3, 6, 5, 11,
	7, 8, 9, 10, 16, 11, -8, -7, 26, -2,
	-3, -3, -3, -3, -2, -2, 25, 17, 17, 17,
	-6,
}
var ParseDef = [...]int{

	0, -2, 16, 2, 13, 0, 0, 8, 0, 0,
	1, 3, 0, 0, 0, 0, 0, 0, 10, 17,
	0, 11, 12, 4, 0, 0, 0, 0, 0, 23,
	0, 14, 0, 0, 9, 0, 0, 5, 0, 0,
	27, 0, 0, 18, 19, 21, 25, 24, 15, 0,
	0, 0, 0, 0, 0, 0, 20, 0, 26, 0,
	29, 30, 31, 32, 0, 0, 0, 6, 28, 7,
	22,
}
var ParseTok1 = [...]int{

	1,
}
var ParseTok2 = [...]int{

	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27,
}
var ParseTok3 = [...]int{
	0,
}

var ParseErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/
// Code generated by goyacc. DO NOT EDIT.

var (
	ParseDebug        = 0
	ParseErrorVerbose = false
)

type ParseLexer interface {
	Lex(lval *ParseSymType) int
	Error(s string)
}

type ParseParser interface {
	Parse(ParseLexer) int
	Lookahead() int
}

type ParseParserImpl struct {
	lval  ParseSymType
	stack [ParseInitialStackSize]ParseSymType
	char  int
}

func (p *ParseParserImpl) Lookahead() int {
	return p.char
}

func ParseNewParser() ParseParser {
	return &ParseParserImpl{}
}

const ParseFlag = -1000

func ParseTokname(c int) string {
	if c >= 1 && c-1 < len(ParseToknames) {
		if ParseToknames[c-1] != "" {
			return ParseToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func ParseStatname(s int) string {
	if s >= 0 && s < len(ParseStatenames) {
		if ParseStatenames[s] != "" {
			return ParseStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func ParseErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !ParseErrorVerbose {
		return "syntax error"
	}

	for _, e := range ParseErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + ParseTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := ParsePact[state]
	for tok := TOKSTART; tok-1 < len(ParseToknames); tok++ {
		if n := base + tok; n >= 0 && n < ParseLast && ParseChk[ParseAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if ParseDef[state] == -2 {
		i := 0
		for ParseExca[i] != -1 || ParseExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; ParseExca[i] >= 0; i += 2 {
			tok := ParseExca[i]
			if tok < TOKSTART || ParseExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if ParseExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += ParseTokname(tok)
	}
	return res
}

func Parselex1(lex ParseLexer, lval *ParseSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = ParseTok1[0]
		goto out
	}
	if char < len(ParseTok1) {
		token = ParseTok1[char]
		goto out
	}
	if char >= ParsePrivate {
		if char < ParsePrivate+len(ParseTok2) {
			token = ParseTok2[char-ParsePrivate]
			goto out
		}
	}
	for i := 0; i < len(ParseTok3); i += 2 {
		token = ParseTok3[i+0]
		if token == char {
			token = ParseTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = ParseTok2[1] /* unknown char */
	}
	if ParseDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", ParseTokname(token), uint(char))
	}
	return char, token
}

func ParseParse(Parselex ParseLexer) int {
	return ParseNewParser().Parse(Parselex)
}

func (Parsercvr *ParseParserImpl) Parse(Parselex ParseLexer) int {
	var Parsen int
	var ParseVAL ParseSymType
	var ParseDollar []ParseSymType
	_ = ParseDollar // silence set and not used
	ParseS := Parsercvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Parsestate := 0
	Parsercvr.char = -1
	Parsetoken := -1 // Parsercvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		Parsestate = -1
		Parsercvr.char = -1
		Parsetoken = -1
	}()
	Parsep := -1
	goto Parsestack

ret0:
	return 0

ret1:
	return 1

Parsestack:
	/* put a state and value onto the stack */
	if ParseDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", ParseTokname(Parsetoken), ParseStatname(Parsestate))
	}

	Parsep++
	if Parsep >= len(ParseS) {
		nyys := make([]ParseSymType, len(ParseS)*2)
		copy(nyys, ParseS)
		ParseS = nyys
	}
	ParseS[Parsep] = ParseVAL
	ParseS[Parsep].yys = Parsestate

Parsenewstate:
	Parsen = ParsePact[Parsestate]
	if Parsen <= ParseFlag {
		goto Parsedefault /* simple state */
	}
	if Parsercvr.char < 0 {
		Parsercvr.char, Parsetoken = Parselex1(Parselex, &Parsercvr.lval)
	}
	Parsen += Parsetoken
	if Parsen < 0 || Parsen >= ParseLast {
		goto Parsedefault
	}
	Parsen = ParseAct[Parsen]
	if ParseChk[Parsen] == Parsetoken { /* valid shift */
		Parsercvr.char = -1
		Parsetoken = -1
		ParseVAL = Parsercvr.lval
		Parsestate = Parsen
		if Errflag > 0 {
			Errflag--
		}
		goto Parsestack
	}

Parsedefault:
	/* default state action */
	Parsen = ParseDef[Parsestate]
	if Parsen == -2 {
		if Parsercvr.char < 0 {
			Parsercvr.char, Parsetoken = Parselex1(Parselex, &Parsercvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if ParseExca[xi+0] == -1 && ParseExca[xi+1] == Parsestate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Parsen = ParseExca[xi+0]
			if Parsen < 0 || Parsen == Parsetoken {
				break
			}
		}
		Parsen = ParseExca[xi+1]
		if Parsen < 0 {
			goto ret0
		}
	}
	if Parsen == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Parselex.Error(ParseErrorMessage(Parsestate, Parsetoken))
			Nerrs++
			if ParseDebug >= 1 {
				__yyfmt__.Printf("%s", ParseStatname(Parsestate))
				__yyfmt__.Printf(" saw %s\n", ParseTokname(Parsetoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Parsep >= 0 {
				Parsen = ParsePact[ParseS[Parsep].yys] + ParseErrCode
				if Parsen >= 0 && Parsen < ParseLast {
					Parsestate = ParseAct[Parsen] /* simulate a shift of "error" */
					if ParseChk[Parsestate] == ParseErrCode {
						goto Parsestack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if ParseDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", ParseS[Parsep].yys)
				}
				Parsep--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if ParseDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", ParseTokname(Parsetoken))
			}
			if Parsetoken == ParseEofCode {
				goto ret1
			}
			Parsercvr.char = -1
			Parsetoken = -1
			goto Parsenewstate /* try again in the same state */
		}
	}

	/* reduction by production Parsen */
	if ParseDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", Parsen, ParseStatname(Parsestate))
	}

	Parsent := Parsen
	Parsept := Parsep
	_ = Parsept // guard against "declared and not used"

	Parsep -= ParseR2[Parsen]
	// Parsep is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if Parsep+1 >= len(ParseS) {
		nyys := make([]ParseSymType, len(ParseS)*2)
		copy(nyys, ParseS)
		ParseS = nyys
	}
	ParseVAL = ParseS[Parsep+1]

	/* consult goto table to find next state */
	Parsen = ParseR1[Parsen]
	Parseg := ParsePgo[Parsen]
	Parsej := Parseg + ParseS[Parsep].yys + 1

	if Parsej >= ParseLast {
		Parsestate = ParseAct[Parseg]
	} else {
		Parsestate = ParseAct[Parsej]
		if ParseChk[Parsestate] != -Parsen {
			Parsestate = ParseAct[Parseg]
		}
	}
	// dummy call; replaced with literal code
	switch Parsent {

	case 1:
		ParseDollar = ParseS[Parsept-2 : Parsept+1]
		//line parse.y:58
		{
			ParsedExprs = ParseDollar[1].exprlist
			ParsedAfters = ParseDollar[2].afterlist
		}
	case 2:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:62
		{
			ParseVAL.exprlist = append(make([]*kd.Expr, 0), ParseDollar[1].expr)
		}
	case 3:
		ParseDollar = ParseS[Parsept-2 : Parsept+1]
		//line parse.y:65
		{
			ParseVAL.exprlist = append(ParseDollar[1].exprlist, ParseDollar[2].expr)
		}
	case 4:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:69
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpAssign, Str: ParseDollar[1].str, ExprL: ParseDollar[3].expr}
			if false {
				fmt.Printf("OMG %s := %v\n", ParseDollar[1].str, ParseDollar[3].expr)
			}
		}
	case 5:
		ParseDollar = ParseS[Parsept-5 : Parsept+1]
		//line parse.y:73
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpVAssign, Str: ParseDollar[1].str, Strlist: ParseDollar[4].strlist}
		}
	case 6:
		ParseDollar = ParseS[Parsept-8 : Parsept+1]
		//line parse.y:76
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpPick, Str: ParseDollar[3].str, ExprL: ParseDollar[5].expr, ExprR: ParseDollar[7].expr}
		}
	case 7:
		ParseDollar = ParseS[Parsept-8 : Parsept+1]
		//line parse.y:79
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpPickh, Str: ParseDollar[3].str, ExprL: ParseDollar[5].expr, ExprR: ParseDollar[7].expr}
		}
	case 8:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:82
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpAll}
		}
	case 9:
		ParseDollar = ParseS[Parsept-4 : Parsept+1]
		//line parse.y:85
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpLabel, Str: ParseDollar[3].str}
		}
	case 10:
		ParseDollar = ParseS[Parsept-2 : Parsept+1]
		//line parse.y:88
		{
			// complement (w.r.t ALL)
			ParseVAL.expr = &kd.Expr{Op: kd.OpNot, ExprL: ParseDollar[2].expr}
		}
	case 11:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:92
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpAnd, ExprL: ParseDollar[1].expr, ExprR: ParseDollar[3].expr}
		}
	case 12:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:95
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpOr, ExprL: ParseDollar[1].expr, ExprR: ParseDollar[3].expr}
		}
	case 13:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:98
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpVar, Str: ParseDollar[1].str}
		}
	case 14:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:102
		{
			ParseVAL.strlist = make([]string, 1)
			ParseVAL.strlist[0] = ParseDollar[1].str
		}
	case 15:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:106
		{
			ParseVAL.strlist = append(ParseDollar[1].strlist, ParseDollar[3].str)
		}
	case 16:
		ParseDollar = ParseS[Parsept-0 : Parsept+1]
		//line parse.y:109
		{
			ParseVAL.afterlist = make([]*kd.After, 0)
		}
	case 17:
		ParseDollar = ParseS[Parsept-2 : Parsept+1]
		//line parse.y:112
		{
			ParseVAL.afterlist = append(ParseDollar[1].afterlist, ParseDollar[2].after)
		}
	case 18:
		ParseDollar = ParseS[Parsept-4 : Parsept+1]
		//line parse.y:116
		{
			ParseVAL.after = &kd.After{Service: ParseDollar[2].pair[0], Stage: ParseDollar[2].pair[1], Pre: ParseDollar[4].conditionlist}
		}
	case 19:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:120
		{
			ParseVAL.conditionlist = append(make([]*kd.Condition, 0), ParseDollar[1].condition)
		}
	case 20:
		ParseDollar = ParseS[Parsept-2 : Parsept+1]
		//line parse.y:123
		{
			ParseVAL.conditionlist = append(ParseDollar[1].conditionlist, ParseDollar[2].condition)
		}
	case 21:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:127
		{
			ParseVAL.condition = &kd.Condition{IsCount: false, Vale: &kd.Expr{Op: kd.OpNum, Num: 100.0}, Service: ParseDollar[1].pair[0], Stage: ParseDollar[1].pair[1]}
		}
	case 22:
		ParseDollar = ParseS[Parsept-4 : Parsept+1]
		//line parse.y:130
		{
			ParseVAL.condition = &kd.Condition{IsCount: !ParseDollar[2].truth, Vale: ParseDollar[1].expr, Service: ParseDollar[4].pair[0], Stage: ParseDollar[4].pair[1]}
		}
	case 23:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:134
		{
			ParseVAL.pair = make([]string, 2)
			ParseVAL.pair[0] = ParseDollar[1].str
		}
	case 24:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:138
		{
			ParseVAL.pair = make([]string, 2)
			ParseVAL.pair[0] = ParseDollar[1].str
			ParseVAL.pair[1] = ParseDollar[3].str
		}
	case 25:
		ParseDollar = ParseS[Parsept-0 : Parsept+1]
		//line parse.y:144
		{
			ParseVAL.truth = false
		}
	case 26:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:145
		{
			ParseVAL.truth = true
		}
	case 27:
		ParseDollar = ParseS[Parsept-1 : Parsept+1]
		//line parse.y:147
		{
			val, _ := strconv.ParseFloat(ParseDollar[1].str, 64)
			ParseVAL.expr = &kd.Expr{Op: kd.OpNum, Num: val}
		}
	case 28:
		ParseDollar = ParseS[Parsept-4 : Parsept+1]
		//line parse.y:151
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpSize, ExprL: ParseDollar[3].expr}
		}
	case 29:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:154
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpPlus, ExprL: ParseDollar[1].expr, ExprR: ParseDollar[3].expr}
		}
	case 30:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:157
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpMinus, ExprL: ParseDollar[1].expr, ExprR: ParseDollar[3].expr}
		}
	case 31:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:160
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpMult, ExprL: ParseDollar[1].expr, ExprR: ParseDollar[3].expr}
		}
	case 32:
		ParseDollar = ParseS[Parsept-3 : Parsept+1]
		//line parse.y:163
		{
			ParseVAL.expr = &kd.Expr{Op: kd.OpDivide, ExprL: ParseDollar[1].expr, ExprR: ParseDollar[3].expr}
		}
	}
	goto Parsestack /* stack new state and value */
}
