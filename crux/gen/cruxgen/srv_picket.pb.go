// Code generated by protoc-gen-go. DO NOT EDIT.
// source: srv_picket.proto

package cruxgen

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StartRequest struct {
	Reqs                 []*StartReq `protobuf:"bytes,1,rep,name=reqs,proto3" json:"reqs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *StartRequest) Reset()         { *m = StartRequest{} }
func (m *StartRequest) String() string { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()    {}
func (*StartRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba7c7e6f1669b2a, []int{0}
}

func (m *StartRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartRequest.Unmarshal(m, b)
}
func (m *StartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartRequest.Marshal(b, m, deterministic)
}
func (m *StartRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartRequest.Merge(m, src)
}
func (m *StartRequest) XXX_Size() int {
	return xxx_messageInfo_StartRequest.Size(m)
}
func (m *StartRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartRequest proto.InternalMessageInfo

func (m *StartRequest) GetReqs() []*StartReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type StartReq struct {
	Filename             string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	Funcname             string   `protobuf:"bytes,2,opt,name=funcname,proto3" json:"funcname,omitempty"`
	Seq                  int32    `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartReq) Reset()         { *m = StartReq{} }
func (m *StartReq) String() string { return proto.CompactTextString(m) }
func (*StartReq) ProtoMessage()    {}
func (*StartReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba7c7e6f1669b2a, []int{1}
}

func (m *StartReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartReq.Unmarshal(m, b)
}
func (m *StartReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartReq.Marshal(b, m, deterministic)
}
func (m *StartReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReq.Merge(m, src)
}
func (m *StartReq) XXX_Size() int {
	return xxx_messageInfo_StartReq.Size(m)
}
func (m *StartReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReq.DiscardUnknown(m)
}

var xxx_messageInfo_StartReq proto.InternalMessageInfo

func (m *StartReq) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *StartReq) GetFuncname() string {
	if m != nil {
		return m.Funcname
	}
	return ""
}

func (m *StartReq) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type StartReply struct {
	Reqs                 []*StartRep `protobuf:"bytes,1,rep,name=reqs,proto3" json:"reqs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *StartReply) Reset()         { *m = StartReply{} }
func (m *StartReply) String() string { return proto.CompactTextString(m) }
func (*StartReply) ProtoMessage()    {}
func (*StartReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba7c7e6f1669b2a, []int{2}
}

func (m *StartReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartReply.Unmarshal(m, b)
}
func (m *StartReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartReply.Marshal(b, m, deterministic)
}
func (m *StartReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReply.Merge(m, src)
}
func (m *StartReply) XXX_Size() int {
	return xxx_messageInfo_StartReply.Size(m)
}
func (m *StartReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReply.DiscardUnknown(m)
}

var xxx_messageInfo_StartReply proto.InternalMessageInfo

func (m *StartReply) GetReqs() []*StartRep {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type StartRep struct {
	Filename             string     `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	Funcname             string     `protobuf:"bytes,2,opt,name=funcname,proto3" json:"funcname,omitempty"`
	UUID                 string     `protobuf:"bytes,3,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Start                *Timestamp `protobuf:"bytes,4,opt,name=start,proto3" json:"start,omitempty"`
	Seq                  int32      `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Err                  *Err       `protobuf:"bytes,6,opt,name=err,proto3" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *StartRep) Reset()         { *m = StartRep{} }
func (m *StartRep) String() string { return proto.CompactTextString(m) }
func (*StartRep) ProtoMessage()    {}
func (*StartRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba7c7e6f1669b2a, []int{3}
}

func (m *StartRep) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartRep.Unmarshal(m, b)
}
func (m *StartRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartRep.Marshal(b, m, deterministic)
}
func (m *StartRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartRep.Merge(m, src)
}
func (m *StartRep) XXX_Size() int {
	return xxx_messageInfo_StartRep.Size(m)
}
func (m *StartRep) XXX_DiscardUnknown() {
	xxx_messageInfo_StartRep.DiscardUnknown(m)
}

var xxx_messageInfo_StartRep proto.InternalMessageInfo

func (m *StartRep) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *StartRep) GetFuncname() string {
	if m != nil {
		return m.Funcname
	}
	return ""
}

func (m *StartRep) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *StartRep) GetStart() *Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *StartRep) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *StartRep) GetErr() *Err {
	if m != nil {
		return m.Err
	}
	return nil
}

type StopRequest struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopRequest) Reset()         { *m = StopRequest{} }
func (m *StopRequest) String() string { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()    {}
func (*StopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba7c7e6f1669b2a, []int{4}
}

func (m *StopRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StopRequest.Unmarshal(m, b)
}
func (m *StopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StopRequest.Marshal(b, m, deterministic)
}
func (m *StopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopRequest.Merge(m, src)
}
func (m *StopRequest) XXX_Size() int {
	return xxx_messageInfo_StopRequest.Size(m)
}
func (m *StopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopRequest proto.InternalMessageInfo

func (m *StopRequest) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

type StopReply struct {
	UUID                 string   `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Err                  *Err     `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopReply) Reset()         { *m = StopReply{} }
func (m *StopReply) String() string { return proto.CompactTextString(m) }
func (*StopReply) ProtoMessage()    {}
func (*StopReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba7c7e6f1669b2a, []int{5}
}

func (m *StopReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StopReply.Unmarshal(m, b)
}
func (m *StopReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StopReply.Marshal(b, m, deterministic)
}
func (m *StopReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopReply.Merge(m, src)
}
func (m *StopReply) XXX_Size() int {
	return xxx_messageInfo_StopReply.Size(m)
}
func (m *StopReply) XXX_DiscardUnknown() {
	xxx_messageInfo_StopReply.DiscardUnknown(m)
}

var xxx_messageInfo_StopReply proto.InternalMessageInfo

func (m *StopReply) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *StopReply) GetErr() *Err {
	if m != nil {
		return m.Err
	}
	return nil
}

func init() {
	proto.RegisterType((*StartRequest)(nil), "cruxgen.StartRequest")
	proto.RegisterType((*StartReq)(nil), "cruxgen.StartReq")
	proto.RegisterType((*StartReply)(nil), "cruxgen.StartReply")
	proto.RegisterType((*StartRep)(nil), "cruxgen.StartRep")
	proto.RegisterType((*StopRequest)(nil), "cruxgen.StopRequest")
	proto.RegisterType((*StopReply)(nil), "cruxgen.StopReply")
}

func init() { proto.RegisterFile("srv_picket.proto", fileDescriptor_6ba7c7e6f1669b2a) }

var fileDescriptor_6ba7c7e6f1669b2a = []byte{
	// 401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xcf, 0x8a, 0xd4, 0x40,
	0x10, 0xc6, 0x37, 0x93, 0xcc, 0x98, 0xd4, 0xec, 0xea, 0xd8, 0x2a, 0x84, 0x1c, 0x24, 0x06, 0x84,
	0xe0, 0x21, 0xe0, 0x2c, 0x22, 0x78, 0x11, 0x41, 0x05, 0x6f, 0x6b, 0xef, 0xec, 0x59, 0xb2, 0xa1,
	0x1c, 0x1b, 0x93, 0x4c, 0xa7, 0xbb, 0xb3, 0x38, 0xef, 0xe0, 0xd3, 0xf8, 0x84, 0xd2, 0x7f, 0xd2,
	0xbb, 0xba, 0x0e, 0xc2, 0xde, 0xaa, 0xea, 0xfb, 0xaa, 0xea, 0x97, 0x4a, 0xc3, 0x4a, 0x8a, 0xab,
	0x2f, 0x9c, 0x35, 0xdf, 0x51, 0x55, 0x5c, 0xec, 0xd4, 0x8e, 0xdc, 0x6b, 0xc4, 0xf8, 0x63, 0x8b,
	0x7d, 0xf6, 0xe0, 0x1b, 0xd6, 0x42, 0x5d, 0x62, 0xed, 0x94, 0x0c, 0x38, 0xeb, 0xb7, 0x2e, 0x4e,
	0x50, 0x08, 0x17, 0x9e, 0x48, 0x14, 0x57, 0xac, 0x41, 0x9b, 0x16, 0xaf, 0xe0, 0xf8, 0x5c, 0xd5,
	0x42, 0x51, 0x1c, 0x46, 0x94, 0x8a, 0x3c, 0x87, 0x48, 0xe0, 0x20, 0xd3, 0x20, 0x0f, 0xcb, 0xe5,
	0xfa, 0x61, 0xe5, 0xc6, 0x57, 0x93, 0x89, 0x1a, 0xb9, 0xd8, 0x40, 0x3c, 0x55, 0x48, 0x06, 0xf1,
	0x57, 0xd6, 0x62, 0x5f, 0x77, 0x98, 0x06, 0x79, 0x50, 0x26, 0xd4, 0xe7, 0x46, 0x1b, 0xfb, 0xc6,
	0x68, 0x33, 0xa7, 0xb9, 0x9c, 0xac, 0x20, 0x94, 0x38, 0xa4, 0x61, 0x1e, 0x94, 0x73, 0xaa, 0xc3,
	0xe2, 0x14, 0xc0, 0x4d, 0xe5, 0xed, 0xfe, 0x7f, 0x28, 0xdc, 0xa1, 0xfc, 0x0a, 0x3c, 0x0b, 0xbf,
	0x33, 0x0b, 0x81, 0xe8, 0xe2, 0xe2, 0xd3, 0x7b, 0x03, 0x93, 0x50, 0x13, 0x93, 0x12, 0xe6, 0x52,
	0xcf, 0x4d, 0xa3, 0x3c, 0x28, 0x97, 0x6b, 0xe2, 0x01, 0x36, 0xac, 0x43, 0xa9, 0xea, 0x8e, 0x53,
	0x6b, 0x98, 0xbe, 0x64, 0xee, 0xbf, 0x84, 0x3c, 0x85, 0x10, 0x85, 0x48, 0x17, 0xa6, 0xf3, 0xd8,
	0x77, 0x7e, 0x10, 0x82, 0x6a, 0xa1, 0x78, 0x06, 0xcb, 0x73, 0xb5, 0xe3, 0xd3, 0xd5, 0xa7, 0xf5,
	0xc1, 0xf5, 0xfa, 0xe2, 0x2d, 0x24, 0xd6, 0xa2, 0x6f, 0xf1, 0x0f, 0xc3, 0xb4, 0x63, 0x76, 0x60,
	0xc7, 0xfa, 0xe7, 0x0c, 0x16, 0x67, 0xe6, 0xad, 0x90, 0x37, 0xee, 0xb0, 0x1f, 0x59, 0x8b, 0x92,
	0x3c, 0xb9, 0xf5, 0x57, 0x35, 0x44, 0xf6, 0xe8, 0xd6, 0x85, 0xdb, 0x7d, 0x71, 0x44, 0x5e, 0x5b,
	0x0e, 0xdb, 0xfa, 0xf8, 0x86, 0xc7, 0xe3, 0x67, 0xe4, 0xaf, 0xaa, 0x6d, 0x7c, 0x09, 0xf1, 0xbb,
	0xb6, 0xb5, 0x7d, 0xf7, 0xaf, 0xf1, 0x3a, 0xae, 0xf6, 0x87, 0x76, 0xbd, 0x80, 0xf8, 0x8c, 0xf5,
	0xdb, 0x8d, 0xbe, 0xc9, 0x89, 0xb7, 0xe8, 0x52, 0xf6, 0x67, 0x5a, 0x1c, 0x91, 0x0a, 0xa2, 0xcf,
	0x23, 0x53, 0x64, 0xe5, 0x05, 0x9d, 0x52, 0x1c, 0x6e, 0xe0, 0xd8, 0x8a, 0x99, 0x7d, 0xb9, 0x30,
	0x0f, 0xfe, 0xf4, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x64, 0xfa, 0xef, 0x44, 0x03, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PicketClient is the client API for Picket service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PicketClient interface {
	StartFiles(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error)
	StopFiles(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error)
	AllFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StartReply, error)
	PingTest(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ping, error)
	Quit(ctx context.Context, in *QuitReq, opts ...grpc.CallOption) (*QuitReply, error)
}

type picketClient struct {
	cc *grpc.ClientConn
}

func NewPicketClient(cc *grpc.ClientConn) PicketClient {
	return &picketClient{cc}
}

func (c *picketClient) StartFiles(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := c.cc.Invoke(ctx, "/cruxgen.Picket/StartFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *picketClient) StopFiles(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopReply, error) {
	out := new(StopReply)
	err := c.cc.Invoke(ctx, "/cruxgen.Picket/StopFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *picketClient) AllFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := c.cc.Invoke(ctx, "/cruxgen.Picket/AllFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *picketClient) PingTest(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ping, error) {
	out := new(Ping)
	err := c.cc.Invoke(ctx, "/cruxgen.Picket/PingTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *picketClient) Quit(ctx context.Context, in *QuitReq, opts ...grpc.CallOption) (*QuitReply, error) {
	out := new(QuitReply)
	err := c.cc.Invoke(ctx, "/cruxgen.Picket/Quit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PicketServer is the server API for Picket service.
type PicketServer interface {
	StartFiles(context.Context, *StartRequest) (*StartReply, error)
	StopFiles(context.Context, *StopRequest) (*StopReply, error)
	AllFiles(context.Context, *Empty) (*StartReply, error)
	PingTest(context.Context, *Ping) (*Ping, error)
	Quit(context.Context, *QuitReq) (*QuitReply, error)
}

func RegisterPicketServer(s *grpc.Server, srv PicketServer) {
	s.RegisterService(&_Picket_serviceDesc, srv)
}

func _Picket_StartFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PicketServer).StartFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cruxgen.Picket/StartFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PicketServer).StartFiles(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Picket_StopFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PicketServer).StopFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cruxgen.Picket/StopFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PicketServer).StopFiles(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Picket_AllFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PicketServer).AllFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cruxgen.Picket/AllFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PicketServer).AllFiles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Picket_PingTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PicketServer).PingTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cruxgen.Picket/PingTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PicketServer).PingTest(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _Picket_Quit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PicketServer).Quit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cruxgen.Picket/Quit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PicketServer).Quit(ctx, req.(*QuitReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Picket_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cruxgen.Picket",
	HandlerType: (*PicketServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartFiles",
			Handler:    _Picket_StartFiles_Handler,
		},
		{
			MethodName: "StopFiles",
			Handler:    _Picket_StopFiles_Handler,
		},
		{
			MethodName: "AllFiles",
			Handler:    _Picket_AllFiles_Handler,
		},
		{
			MethodName: "PingTest",
			Handler:    _Picket_PingTest_Handler,
		},
		{
			MethodName: "Quit",
			Handler:    _Picket_Quit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "srv_picket.proto",
}
